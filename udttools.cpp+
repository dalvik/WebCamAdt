#include "jni.h"
//#include <utils/Log.h>

#define LOGI(fmt, args...) __android_log_print(ANDROID_LOG_INFO, LOG_TAG, fmt, ##args)
#define LOGD(fmt, args...) __android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, fmt, ##args)
#define LOGE(fmt, args...) __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, fmt, ##args) 

#include<android/log.h>

#define LOG_TAG "webcam"

#include <arpa/inet.h>
#include <netdb.h>
#include <cstdlib>
#include <cstring>
#include <fstream>
#include <iostream>
#include <udt.h>

using namespace std;

char*  jstringToChar(JNIEnv* env, jstring jstr )
{
	
	   char* rtn = NULL; 
	   jclass clsstring = env->FindClass("java/lang/String"); 
	   jstring strencode = env->NewStringUTF("utf-8"); 
	   jmethodID mid = env->GetMethodID(clsstring, "getBytes", "(Ljava/lang/String;)[B"); 
	   jbyteArray barr= (jbyteArray)env->CallObjectMethod(jstr, mid, strencode); 
	   jsize alen = env->GetArrayLength(barr); 
	   jbyte* ba = env->GetByteArrayElements(barr, JNI_FALSE); 
	   if (alen > 0) 
	   { 
			 rtn = (char*)malloc(alen + 1); 
			 memcpy(rtn, ba, alen); 
			 rtn[alen] = 0; 
	   } 
	   env->ReleaseByteArrayElements(barr, ba, 0); 
    return rtn;
} 

extern "C" jint JNICALL Java_com_test_UdtTools_recvFile(JNIEnv *env, jobject thiz,jstring udtServerIp, jstring udtServerPort, jstring remoteFileName, jstring localFileName) {
	LOGI("--->webcam jni init success");
  	UDT::startup();
  
	struct addrinfo hints, *peer;

	memset(&hints, 0, sizeof(struct addrinfo));
   	hints.ai_flags = AI_PASSIVE;
   	hints.ai_family = AF_INET;
   	hints.ai_socktype = SOCK_STREAM;

	char* ip = jstringToChar(env,udtServerIp);
	char* port = jstringToChar(env,udtServerPort);
	UDTSOCKET fhandle = UDT::socket(hints.ai_family, hints.ai_socktype, hints.ai_protocol);
 	if (0 != getaddrinfo(ip, port, &hints, &peer))
   	{
		LOGI("--->incorrect server/peer address %s,%s",ip,port);
      		return -1;
   	} 

	// connect to the server, implict bind
   	if (UDT::ERROR == UDT::connect(fhandle, peer->ai_addr, peer->ai_addrlen))
  	{
		LOGI("---> connect server error %s",UDT::getlasterror().getErrorMessage());
      		//cout << "connect: " << UDT::getlasterror().getErrorMessage() << endl;
      		return -1;
   	}


	freeaddrinfo(peer);

	// send name information of the requested file
	char * remoteFile = jstringToChar(env,remoteFileName);
   	int len = strlen(remoteFile);
	LOGI("len = %d", len);

   	if (UDT::ERROR == UDT::send(fhandle, (char*)&len, sizeof(int), 0))
   	{
		LOGI("---> send error %s",UDT::getlasterror().getErrorMessage());
      		//cout << "send: " << UDT::getlasterror().getErrorMessage() << endl;
      		return -1;
   	}

   	if (UDT::ERROR == UDT::send(fhandle, remoteFile, len, 0))
   	{
		LOGI("---> send error %s",UDT::getlasterror().getErrorMessage());
      		//cout << "send: " << UDT::getlasterror().getErrorMessage() << endl;
      		return -1;
   	}

   	// get size information
   	int64_t size;

   	if (UDT::ERROR == UDT::recv(fhandle, (char*)&size, sizeof(int64_t), 0))
   	{
		LOGI("---> send error %s",UDT::getlasterror().getErrorMessage());
      		//cout << "send: " << UDT::getlasterror().getErrorMessage() << endl;
      		return -1;
   	}

   	if (size < 0)
   	{
		LOGI("---> no such file on the server %s",remoteFile);
		//cout << "no such file " << remoteFile << " on the server\n";
      		return -1;
   	}

   	// receive the file
	char* savFileName = jstringToChar(env,localFileName);
   	fstream ofs(savFileName, ios::out | ios::binary | ios::trunc);
   	int64_t recvsize; 
   	int64_t offset = 0;
 	LOGI("recvFile ---------------%s",savFileName); 
 	LOGI("handle---------------%p",fhandle); 
 	LOGI("ofs---------------%p",&ofs); 
 	LOGI("size---------------%d",size); 
	if (ofs.is_open())
 	LOGI("ofs---------------"); 
else 
 	LOGI("ofs");


   	if (UDT::ERROR == (recvsize = UDT::recvfile(fhandle, ofs, offset, 1688)))
   	{
//		LOGI("---> revefile error %s",UDT::getlasterror().getErrorMessage());
      		//cout << "recvfile: " << UDT::getlasterror().getErrorMessage() << endl;
      		return -1;
   	}

 	LOGI("recvFile ----------%s",savFileName); 
   	UDT::close(fhandle);

   	ofs.close();
 	// use this function to release the UDT library
   	UDT::cleanup();
  
    return 0;
}

#ifndef WIN32
void* sendfile(void* usocket)
#else
DWORD WINAPI sendfile(LPVOID usocket)
#endif
{
   UDTSOCKET fhandle = *(UDTSOCKET*)usocket;
   delete (UDTSOCKET*)usocket;

   // aquiring file name information from client
   char file[1024];
   int len;

   if (UDT::ERROR == UDT::recv(fhandle, (char*)&len, sizeof(int), 0))
   {
     LOGI("recv: %s",UDT::getlasterror().getErrorMessage());
      //cout << "recv: " << UDT::getlasterror().getErrorMessage() << endl;
      return 0;
   }

   if (UDT::ERROR == UDT::recv(fhandle, file, len, 0))
   {
     LOGI("recv:%s",UDT::getlasterror().getErrorMessage());
     // cout << "recv: " << UDT::getlasterror().getErrorMessage() << endl;
      return 0;
   }
   file[len] = '\0';

   // open the file
   fstream ifs(file, ios::in | ios::binary);

   ifs.seekg(0, ios::end);
   int64_t size = ifs.tellg();
   ifs.seekg(0, ios::beg);

   // send file size information
   if (UDT::ERROR == UDT::send(fhandle, (char*)&size, sizeof(int64_t), 0))
   {
     LOGI("send:%s",UDT::getlasterror().getErrorMessage());
     //. cout << "send: " << UDT::getlasterror().getErrorMessage() << endl;
      return 0;
   }

   UDT::TRACEINFO trace;
   UDT::perfmon(fhandle, &trace);

   // send the file
   int64_t offset = 0;
   if (UDT::ERROR == UDT::sendfile(fhandle, ifs, offset, size))
   {
     // cout << "sendfile: " << UDT::getlasterror().getErrorMessage() << endl;
      LOGI("sendfile: %s", UDT::getlasterror().getErrorMessage());
      return 0;
   }

   UDT::perfmon(fhandle, &trace);
   //cout << "speed = " << trace.mbpsSendRate << "Mbits/sec" << endl;
   LOGI("speed = %s Mbits/sec",trace.mbpsSendRate);
   UDT::close(fhandle);

   ifs.close();

   #ifndef WIN32
      return NULL;
   #else
      return 0;
   #endif
}


extern "C" jint JNICALL Java_com_test_UdtTools_sendFile(JNIEnv *env, jobject thiz,jstring sendFileName, jstring sendPort)
{
 // use this function to initialize the UDT library
   UDT::startup();

   addrinfo hints;
   addrinfo* res;

   memset(&hints, 0, sizeof(struct addrinfo));
   hints.ai_flags = AI_PASSIVE;
   hints.ai_family = AF_INET;
   hints.ai_socktype = SOCK_STREAM;

   char* port = jstringToChar(env,sendPort);
   string service(port);
   if (0 != getaddrinfo(NULL, service.c_str(), &hints, &res))
   {
      LOGI("illeagel port number or port is busy at %s",port);
      //cout << "illegal port number or port is busy.\n" << endl;
      return 0;
   }

	UDTSOCKET serv = UDT::socket(res->ai_family, res->ai_socktype, res->ai_protocol);

   // Windows UDP issue
   // For better performance, modify HKLM\System\CurrentControlSet\Services\Afd\Parameters\FastSendDatagramThreshold
#ifdef WIN32
   int mss = 1052;
   UDT::setsockopt(serv, 0, UDT_MSS, &mss, sizeof(int));
#endif

   if (UDT::ERROR == UDT::bind(serv, res->ai_addr, res->ai_addrlen))
   {
      LOGI("bind error %s",UDT::getlasterror().getErrorMessage());
//      cout << "bind: " << UDT::getlasterror().getErrorMessage() << endl;
      return 0;
   }

   freeaddrinfo(res);
   LOGI("server is read at port:%s",service );
   //cout << "server is ready at port: " << service << endl;


   UDT::listen(serv, 10);

   sockaddr_storage clientaddr;
   int addrlen = sizeof(clientaddr);

   UDTSOCKET fhandle;

   while (true)
   {
      if (UDT::INVALID_SOCK == (fhandle = UDT::accept(serv, (sockaddr*)&clientaddr, &addrlen)))
      {
         LOGI("accept error %s ",UDT::getlasterror().getErrorMessage());
        // cout << "accept: " << UDT::getlasterror().getErrorMessage() << endl;
         return 0;
      }

      char clienthost[NI_MAXHOST];
      char clientservice[NI_MAXSERV];
      getnameinfo((sockaddr *)&clientaddr, addrlen, clienthost, sizeof(clienthost), clientservice, sizeof(clientservice), NI_NUMERICHOST|NI_NUMERICSERV);
      //cout << "new connection: " << clienthost << ":" << clientservice << endl;
      LOGI("new connection %s:%s",clienthost,clientservice);
      #ifndef WIN32
         pthread_t filethread;
         pthread_create(&filethread, NULL, sendfile, new UDTSOCKET(fhandle));
         pthread_detach(filethread);
      #else
         CreateThread(NULL, 0, sendfile, new UDTSOCKET(fhandle), 0, NULL);
      #endif
   }

   UDT::close(serv);

   // use this function to release the UDT library
 // use this function to release the UDT library
   UDT::cleanup();

   return 0;
}
